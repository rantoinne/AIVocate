<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vosk STT Test Client</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .connected { background-color: #d4edda; color: #155724; }
        .disconnected { background-color: #f8d7da; color: #721c24; }
        .transcript {
            background-color: #f8f9fa;
            padding: 20px;
            border-radius: 5px;
            margin: 20px 0;
            min-height: 100px;
        }
        .partial { color: #6c757d; font-style: italic; }
        .final { color: #000; font-weight: bold; }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .start { background-color: #28a745; color: white; }
        .stop { background-color: #dc3545; color: white; }
        .disabled { background-color: #6c757d; color: white; cursor: not-allowed; }
    </style>
</head>
<body>
    <h1>Vosk Speech-to-Text Test Client</h1>
    
    <div class="controls">
        <button id="connectBtn" class="start">Connect</button>
        <button id="startBtn" class="start disabled" disabled>Start Recording</button>
        <button id="stopBtn" class="stop disabled" disabled>Stop Recording</button>
        <button id="resetBtn" class="disabled" disabled>Reset</button>
        <button id="vocabStatsBtn" class="disabled" disabled>Vocabulary Stats</button>
        <button id="updateVocabBtn" class="disabled" disabled>Update Vocabulary</button>
    </div>
    
    <div>
        <input type="text" id="searchInput" placeholder="Search similar terms..." style="width: 200px;">
        <button id="searchBtn" class="disabled" disabled>Search</button>
    </div>
    
    <div id="status" class="status disconnected">Disconnected</div>
    
    <div class="transcript">
        <h3>Live Transcript:</h3>
        <div id="partialTranscript" class="partial"></div>
        <div id="finalTranscript" class="final"></div>
        <div id="suggestions" style="margin-top: 10px; font-size: 0.9em; color: #666;"></div>
    </div>
    
    <div>
        <h3>Vocabulary Info:</h3>
        <div id="vocabularyInfo">Smart vocabulary learning enabled...</div>
    </div>
    
    <div>
        <h3>Debug Info:</h3>
        <pre id="debugInfo"></pre>
    </div>

    <script>
        class VoskSTTClient {
            constructor() {
                this.ws = null;
                this.mediaRecorder = null;
                this.audioStream = null;
                this.isRecording = false;
                this.audioContext = null;
                this.processor = null;
                
                this.setupUI();
            }
            
            setupUI() {
                document.getElementById('connectBtn').addEventListener('click', () => this.connect());
                document.getElementById('startBtn').addEventListener('click', () => this.startRecording());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopRecording());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('vocabStatsBtn').addEventListener('click', () => this.getVocabularyStats());
                document.getElementById('updateVocabBtn').addEventListener('click', () => this.updateVocabulary());
                document.getElementById('searchBtn').addEventListener('click', () => this.searchTerms());
            }
            
            async connect() {
                try {
                    this.ws = new WebSocket('ws://localhost:8765');
                    
                    this.ws.onopen = () => {
                        this.updateStatus('Connected', 'connected');
                        this.enableButtons(['startBtn', 'resetBtn', 'vocabStatsBtn', 'updateVocabBtn', 'searchBtn']);
                        this.disableButtons(['connectBtn']);
                        this.log('WebSocket connected');
                    };
                    
                    this.ws.onmessage = (event) => {
                        const data = JSON.parse(event.data);
                        this.handleMessage(data);
                    };
                    
                    this.ws.onclose = () => {
                        this.updateStatus('Disconnected', 'disconnected');
                        this.enableButtons(['connectBtn']);
                        this.disableButtons(['startBtn', 'stopBtn', 'resetBtn', 'vocabStatsBtn', 'updateVocabBtn', 'searchBtn']);
                        this.log('WebSocket disconnected');
                    };
                    
                    this.ws.onerror = (error) => {
                        this.log('WebSocket error: ' + error);
                        this.updateStatus('Connection Error', 'disconnected');
                    };
                    
                } catch (error) {
                    this.log('Connection failed: ' + error.message);
                    this.updateStatus('Connection Failed', 'disconnected');
                }
            }
            
            handleMessage(data) {
                switch (data.type) {
                    case 'connection':
                        this.log('Server ready for audio');
                        break;
                    case 'partial':
                        document.getElementById('partialTranscript').textContent = data.transcript;
                        break;
                    case 'final':
                        const finalDiv = document.getElementById('finalTranscript');
                        finalDiv.innerHTML += data.transcript + ' ';
                        document.getElementById('partialTranscript').textContent = '';
                        this.log(`Final: "${data.transcript}" (confidence: ${data.confidence})`);
                        break;
                    case 'error':
                        this.log('Server error: ' + data.message);
                        break;
                    case 'status':
                        this.log('Status: ' + data.message);
                        break;
                }
            }
            
            async startRecording() {
                try {
                    // Get audio stream
                    this.audioStream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            sampleRate: 16000,
                            channelCount: 1,
                            echoCancellation: true,
                            noiseSuppression: true
                        }
                    });
                    
                    // Create audio context for processing
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 16000
                    });
                    
                    const source = this.audioContext.createMediaStreamSource(this.audioStream);
                    
                    // Create processor for audio chunks
                    this.processor = this.audioContext.createScriptProcessor(4096, 1, 1);
                    
                    this.processor.onaudioprocess = (event) => {
                        if (this.isRecording && this.ws && this.ws.readyState === WebSocket.OPEN) {
                            const inputBuffer = event.inputBuffer.getChannelData(0);
                            
                            // Convert float32 to int16
                            const int16Buffer = new Int16Array(inputBuffer.length);
                            for (let i = 0; i < inputBuffer.length; i++) {
                                int16Buffer[i] = Math.max(-32768, Math.min(32767, inputBuffer[i] * 32768));
                            }
                            
                            // Send to WebSocket
                            this.ws.send(int16Buffer.buffer);
                        }
                    };
                    
                    source.connect(this.processor);
                    this.processor.connect(this.audioContext.destination);
                    
                    this.isRecording = true;
                    this.updateStatus('Recording...', 'connected');
                    this.enableButtons(['stopBtn']);
                    this.disableButtons(['startBtn']);
                    this.log('Recording started');
                    
                } catch (error) {
                    this.log('Error starting recording: ' + error.message);
                    this.updateStatus('Recording Error', 'disconnected');
                }
            }
            
            stopRecording() {
                this.isRecording = false;
                
                if (this.processor) {
                    this.processor.disconnect();
                    this.processor = null;
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                    this.audioContext = null;
                }
                
                if (this.audioStream) {
                    this.audioStream.getTracks().forEach(track => track.stop());
                    this.audioStream = null;
                }
                
                this.updateStatus('Connected', 'connected');
                this.enableButtons(['startBtn']);
                this.disableButtons(['stopBtn']);
                this.log('Recording stopped');
            }
            
            reset() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ action: 'reset' }));
                }
                document.getElementById('partialTranscript').textContent = '';
                document.getElementById('finalTranscript').innerHTML = '';
                this.log('Transcript reset');
            }
            
            updateStatus(message, className) {
                const statusDiv = document.getElementById('status');
                statusDiv.textContent = message;
                statusDiv.className = 'status ' + className;
            }
            
            enableButtons(buttonIds) {
                buttonIds.forEach(id => {
                    const btn = document.getElementById(id);
                    btn.disabled = false;
                    btn.classList.remove('disabled');
                });
            }
            
            disableButtons(buttonIds) {
                buttonIds.forEach(id => {
                    const btn = document.getElementById(id);
                    btn.disabled = true;
                    btn.classList.add('disabled');
                });
            }
            
            getVocabularyStats() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ action: 'get_vocabulary_stats' }));
                }
            }
            
            updateVocabulary() {
                if (this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({ action: 'force_vocabulary_update' }));
                    this.log('🔄 Updating vocabulary from live sources...');
                }
            }
            
            searchTerms() {
                const input = document.getElementById('searchInput');
                const query = input.value.trim();
                
                if (query && this.ws && this.ws.readyState === WebSocket.OPEN) {
                    this.ws.send(JSON.stringify({
                        action: 'search_terms',
                        query: query
                    }));
                    this.log(`🔍 Searching for terms similar to: ${query}`);
                }
            }
            
            log(message) {
                const debugInfo = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.textContent += `[${timestamp}] ${message}\n`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }
        
        // Initialize client when page loads
        window.addEventListener('load', () => {
            new VoskSTTClient();
        });
    </script>
</body>
</html>